SOLID = 5 Design Principles

Single Responsibility
Openâ€“Closed
Liskov Substitution
Interface Segregation
Dependency Inversion

1. Single Responsibility: A class should have only ONE reason to change.
Real-life analogy
A restaurant:
> Chef cooks
> Cashier handles payments
> Manager manages staff
> One person doing all â†’ chaos.

âŒ Bad Code (very common)
class SRP.OrderService {
    void createOrder() { }
    void calculatePrice() { }
    void saveToDB() { }
    void sendEmail() { }
}
This class changes if:
 >> order changes
 >> price changes
 >> DB Changes
 >> Email Service Changes
 4 Reason to change = SRP Broke

class SRP.OrderService {
    private SRP.PriceCalculator calculator;
    private SRP.OrderRepository repository;
    private EmailService emailService;

    void placeOrder(SRP.Order order) {
        calculator.calculate(order);
        repository.save(order);
        emailService.send(order);
    }
}
class SRP.PriceCalculator { }
class SRP.OrderRepository { }
class EmailService { }
âœ” Each class has one responsibility


ğŸ”´ Bad Code Example (Typical)
class UserService {

    void registerUser(SRP.User user) {
        if (!user.getEmail().contains("@")) {
            throw new RuntimeException("Invalid email");
        }

        // save user
        System.out.println("Saving user to DB");

        // send email
        System.out.println("Sending welcome email");
    }
}

ğŸš¨ Whatâ€™s wrong?

This class changes if:
Validation rules change
DB changes
Email service changes
ğŸ‘‰ 3 reasons to change = SRP broken

ğŸŸ¢ Correct SRP Design
class SRP.UserValidator {
    void validate(SRP.User user) { }
}
class SRP.UserRepository {
    void save(SRP.User user) { }
}
class EmailService {
    void sendWelcomeEmail(SRP.User user) { }
}
class UserRegistrationService {
    private SRP.UserValidator validator;
    private SRP.UserRepository repository;
    private EmailService emailService;
    void register(SRP.User user) {
        validator.validate(user);
        repository.save(user);
        emailService.sendWelcomeEmail(user);
    }
}
âœ” Each class has ONE job
âœ” Easy to test
âœ” Easy to change

SRP is not about lines of code, itâ€™s about change impact


//////////////////////////////////////////////////////////////////

ğŸŸ¢ Openâ€“Closed Principle (OCP)
ğŸ”¹ Definition
Software entities should be open for extension, but closed for modification.
In simple words:
âŒ Donâ€™t edit working code to add features
âœ… Add new behavior by adding new code
ğŸ”¹ Why OCP Exists (Real Pain)
Imagine your app is in production.
You change:
if (type.equals("EMAIL")) ...
ğŸ’¥ Suddenly payments break
ğŸ’¥ Hotfix at 2 AM
ğŸ’¥ Everyone is angry
OCP prevents this.
ğŸ”´ OCP VIOLATION (Very Common)
âŒ Naive Notification System
class NotificationService {
    void send(String type, User user) {
        if (type.equals("EMAIL")) {
            System.out.println("Email sent");
        } else if (type.equals("SMS")) {
            System.out.println("SMS sent");
        } else if (type.equals("PUSH")) {
            System.out.println("Push sent");
        }
    }
}

ğŸš¨ Problems
Add WhatsApp â†’ modify this class
Remove SMS â†’ modify this class
Violates OCP badly
ğŸŸ¢ OCP-Correct Design
Step 1: Introduce abstraction
interface Notification {
    void send(User user);
}

Step 2: One class per behavior
class EmailNotification implements Notification {
    public void send(User user) {
        System.out.println("Email sent to " + user.getName());
    }
}

class SmsNotification implements Notification {
    public void send(User user) {
        System.out.println("SMS sent to " + user.getName());
    }
}
Step 3: Service depends on abstraction
class NotificationService {
    private Notification notification;
    NotificationService(Notification notification) {
        this.notification = notification;
    }
    void notify(User user) {
        notification.send(user);
    }
}
ğŸ”¥ Result
Add WhatsApp â†’ create new class
No existing code touched
OCP satisfied
ğŸ— Real-World Example (Important)
Payment System (BookMyShow / Uber)
Bad:
if (paymentType.equals("UPI")) ...
Good:
interface PaymentMethod {
    void pay();
}
Add CryptoPayment tomorrow â†’ zero changes.
ğŸ§  OCP Interview Sentence (Memorize This)
â€œWe achieve OCP using polymorphism and abstractions so that new behavior is added by extension, not modification.â€

4ï¸âƒ£ Hidden Interview Question (You Can Answer This Now)
Q: â€œHow is this different from Strategy Pattern?â€
Answer (Golden):
â€œOCP is a principle, and Strategy Pattern is one way to implement it.
 Here, each PaymentMethod is a strategy selected at runtime.â€


 ğŸŸ¢ Liskov Substitution Principle (LSP)
 ğŸ”¹ Definition (Formal)
 Objects of a superclass should be replaceable with objects of its subclasses without breaking the program.
 ğŸ”¹ Human version
 If a class B extends A, then anywhere A is expected, B should work without surprises.
 No crashes.
 No â€œnot supportedâ€.
 No behavior change.
 ğŸ”¥ Why LSP Exists (Real Pain)
 You write:
 processPayment(Payment payment)
 Someone passes a subclass.
 ğŸ’¥ Runtime exception
 ğŸ’¥ Hidden bug
 ğŸ’¥ â€œBut it compiled!!â€
 LSP exists to prevent lying inheritance.
 ğŸ”´ Classic LSP Violation (Very Important)
 âŒ Wrong Design
 class Bird {
     void fly() {
         System.out.println("Flying");
     }
 }

 class Penguin extends Bird {
     @Override
     void fly() {
         throw new UnsupportedOperationException("Penguins can't fly");
     }
 }

 ğŸš¨ Why this violates LSP
 Penguin IS NOT substitutable for Bird
 Any code expecting Bird.fly() will break
 ğŸ‘‰ Inheritance used incorrectly
 ğŸŸ¢ Correct LSP Design
 Step 1: Identify real behavior
 Not all birds fly.
 Step 2: Split abstraction
 interface Bird { }

 interface FlyingBird extends Bird {
     void fly();
 }

 Step 3: Correct implementations
 class Sparrow implements FlyingBird {
     public void fly() {
         System.out.println("Sparrow flying");
     }
 }

 class Penguin implements Bird {
     void swim() {
         System.out.println("Penguin swimming");
     }
 }
 âœ” No fake behavior
 âœ” No exceptions
 âœ” LSP respected
 ğŸ§  LSP Golden Rule (Memorize)
 If a subclass throws â€œnot supportedâ€, checks type, or weakens behavior â†’ LSP is broken.
 ğŸ”´ Another Common LSP Violation (Business Logic)
 âŒ Bad Example
 class Account {
     void withdraw(double amount) { }
 }
 class FixedDepositAccount extends Account {
     @Override
     void withdraw(double amount) {
         throw new RuntimeException("Withdrawal not allowed");
     }
 }
 ğŸ’¥ BOOM â€” LSP violation.
 ğŸŸ¢ Correct Design
 interface WithdrawableAccount {
     void withdraw(double amount);
 }
 class SavingsAccount implements WithdrawableAccount { }
 class FixedDepositAccount {
     // no withdraw
 }
 âœ” Behavior matches abstraction.
 ğŸ— Real-World Example (Very Interview-Relevant)
 Ride Booking App ğŸš•ğŸï¸
 âŒ Wrong:
 class Ride {
     int getSeatCount() { return 4; }
 }

 class BikeRide extends Ride {
     int getSeatCount() { return 1; }
 }
 ğŸ’¥ Code expecting 4 seats breaks.
 âœ… Correct:
 interface Ride {
     int getSeatCount();
 }

 class BikeRide implements Ride {
     public int getSeatCount() { return 1; }
 }

 class CarRide implements Ride {
     public int getSeatCount() { return 4; }
 }
 âœ” Fully substitutable.
 ğŸ§  How Interviewers Check LSP
 They look for:
 instanceof
 throw new UnsupportedOperationException
 â€œSpecial caseâ€ logic in subclasses
 If they see that â†’ âŒ LSP broken.
 ğŸ›  YOUR LSP ASSIGNMENT
 ğŸ¯ Problem: Document Processing System
 Requirements:
 System processes documents and prints them.
 Types:
 PDF document
 Word document
 Read-only document (cannot be printed)
 âŒ WRONG Approach (Do NOT do this)
 class Document {
     void print() { }
 }
 class ReadOnlyDocument extends Document {
     void print() {
         throw new RuntimeException("Cannot print");
     }
 }

 ğŸš« This violates LSP.
